package com.lemondo.commons.db;

import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.sql.DataSource;

public abstract class Helper {

	private static final Set<Integer> UNIQUE_KEY_VIOLATION_CODES = new HashSet<Integer>();
	static {
		UNIQUE_KEY_VIOLATION_CODES.add(1022);
		UNIQUE_KEY_VIOLATION_CODES.add(1062);
		UNIQUE_KEY_VIOLATION_CODES.add(1169);
		UNIQUE_KEY_VIOLATION_CODES.add(1586);
	}

	private static final Set<Integer> FOREIGN_KEY_VIOLATION_CODES = new HashSet<Integer>();
	static {
		FOREIGN_KEY_VIOLATION_CODES.add(1216);
		FOREIGN_KEY_VIOLATION_CODES.add(1217);
		FOREIGN_KEY_VIOLATION_CODES.add(1451);
		FOREIGN_KEY_VIOLATION_CODES.add(1452);
	}

	private static final Set<Integer> NOT_NULL_VIOLATION_CODES = new HashSet<Integer>();
	static {
		NOT_NULL_VIOLATION_CODES.add(1364);
		NOT_NULL_VIOLATION_CODES.add(1048);
	}

	public static boolean isUniqueKeyViolation(SQLException e) {
		return UNIQUE_KEY_VIOLATION_CODES.contains(e.getErrorCode());
	}

	public static boolean isForeignKeyViolation(SQLException e) {
		return FOREIGN_KEY_VIOLATION_CODES.contains(e.getErrorCode());
	}

	public static boolean isNotNullViolation(SQLException e) {
		return NOT_NULL_VIOLATION_CODES.contains(e.getErrorCode());
	}

	private List<Statement> statementPool;

	protected Connection conn;

	protected Helper() {
		this.statementPool = new ArrayList<Statement>();
	}

	private static class PlainJdbcHelper extends Helper {

		private final String uri;
		private final String userName;
		private final String password;

		private PlainJdbcHelper(String driverName, String uri, String userName, String password) throws ClassNotFoundException {
			super();

			this.uri = uri;
			this.userName = userName;
			this.password = password;

			Class.forName(driverName);
		}

		@Override
		public Connection getConnection() throws SQLException {
			return (this.conn == null) ? (this.conn = DriverManager.getConnection(uri, userName, password)) : this.conn;
		}

	}

	private static class DataSourceHelper extends Helper {

		private final DataSource ds;

		private DataSourceHelper(DataSource ds) {
			super();
			this.ds = ds;
		}

		private DataSourceHelper(String dataSourceJndi) throws NamingException {
			super();
			this.ds = (DataSource) new InitialContext().lookup(dataSourceJndi);
		}

		@Override
		public Connection getConnection() throws SQLException {
			return (this.conn == null) ? (this.conn = ds.getConnection()) : this.conn;
		}
	}

	public static Helper getInstance(DataSource ds) {
		return new DataSourceHelper(ds);
	}

	public static Helper getInstance(String dataSourceJndi) throws NamingException {
		return new DataSourceHelper(dataSourceJndi);
	}

	public static Helper getInstance(String driverName, String uri, String userName, String password) throws ClassNotFoundException {
		return new PlainJdbcHelper(driverName, uri, userName, password);
	}

	public abstract Connection getConnection() throws SQLException;

	public PreparedStatement prepareStatement(String sqlStatement) throws SQLException {
		PreparedStatement stmnt = this.getConnection().prepareStatement(sqlStatement);
		this.statementPool.add(stmnt);
		return stmnt;
	}

	public PreparedStatement prepareStatement(String sqlStatement, int autoGeneratedKeys) throws SQLException {
		PreparedStatement stmnt = this.getConnection().prepareStatement(sqlStatement, autoGeneratedKeys);
		this.statementPool.add(stmnt);
		return stmnt;
	}

	public CallableStatement prepareCall(String sqlStatement) throws SQLException {
		CallableStatement stmnt = this.getConnection().prepareCall(sqlStatement);
		this.statementPool.add(stmnt);
		return stmnt;
	}

	private void close(Statement stmnt) {
		try {
			if (stmnt != null && !stmnt.isClosed()) {
				stmnt.close();
			}
		} catch (SQLException e) {
			System.err.println("WARNING: Error during finalization (possible memory leak): Cannot close Statement:");
			e.printStackTrace(System.err);
		}
	}

	private void close(Connection conn) {
		try {
			if (conn != null && !conn.isClosed()) {
				conn.close();
			}
		} catch (SQLException e) {
			System.err.println("WARNING: Error during finalization (possible memory leak): Cannot close Connection:");
			e.printStackTrace(System.err);
		}
	}

	public void cleanup() {
		for (Statement stmnt : this.statementPool) {
			close(stmnt);
		}
		close(this.conn);
	}

}
